# -*- mode: Snakemake -*-
# Look into turning the metadata into a dictionary
# Sequence Trimming Rules

rule seq_trim:
  input:
    seq="{sample}.{read}.fastq.gz"
  output:
    "{sample}.{read}.trim.fastq.gz"
  params:
    R1lead=lambda wildcards: R1leadTrim[wildcards.sample],
    R1over=lambda wildcards: R1overTrim[wildcards.sample],
    R2lead=lambda wildcards: R2leadTrim[wildcards.sample],
    R2over=lambda wildcards: R2overTrim[wildcards.sample]
  shell:
    """
    TOOL="'{ROOT_DIR}'/tools/seqTrimR/seqTrim.R"
    READ=$(echo {input} | cut -d '.' -f 2)
    if [ ${{READ}} = "R1" ]
      Rscript ${{TOOL}} {RUN_DIR}/process/demultiplexed/{input.seq} \
        -o {RUN_DIR}/process/trimmed/{output} \
        -l {params.R1lead} -r {params.R1over} --compress
    else
      Rscript ${{TOOL}} {RUN_DIR}/process/demultiplexed/{input.seq} \
        -o {RUN_DIR}/process/trimmed/{output} \
        -l {params.R2lead} -r {params.R2over} --compress
    fi
    """

